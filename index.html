<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chat Tributo</title>
  <link rel="stylesheet" href="style.css">
  <link rel="icon" type="image" href="icon.png">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/11.1.1/marked.min.js"></script>
</head>
<body>
<div class="app-layout">
  <!-- Sidebar -->
  <aside class="sidebar">
    <div class="brand">
      <div class="brand-icon">üèõÔ∏è</div>
      <div class="brand-name">Chat Tributo</div>
      <div class="brand-tagline">Trusted guidance for your future</div>
    </div>
    
    <div class="session-info">
      <div class="session-label">Session ID</div>
      <div class="session-id-display" id="sessionDisplay"></div>
    </div>
    
    <button class="new-chat-btn" id="newChatBtn">
      Nova Conversa
    </button>
  </aside>
  
  <!-- Main Chat -->
  <main class="chat-main">
    <header class="chat-header">
      <div class="header-title">Assistente Tribut√°rio</div>

    </header>
    
    <div class="messages-container" id="messagesContainer">
      <div class="empty-state">
        <div class="empty-icon">üí∞</div>
        <div class="empty-title">Bem-vind@ ao Chat Tributo</div>
        <div class="empty-subtitle">
          I'm here to help you navigate your financial journey. 
          Ask me about budgeting, investments, savings strategies, or any financial concerns you have.
        </div>
      </div>
    </div>
    
    <div class="input-section">
      <div class="input-container">
        <input 
          type="text" 
          id="userInput" 
          placeholder="Ask about budgeting, investments, savings strategies..."
          autocomplete="off"
        />
        <button id="sendButton">Enviar</button>
      </div>
    </div>
  </main>
</div>

<script>
const ENDPOINT = "https://enough-blatantly-whale.ngrok-free.app/chat";

// Generate session ID
function generateSessionId() {
  return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
}

let sessionId = generateSessionId();
let streamingEnabled = false;
let isStreaming = false;

// UI Elements
const messagesContainer = document.getElementById('messagesContainer');
const userInput = document.getElementById('userInput');
const sendButton = document.getElementById('sendButton');
const sessionDisplay = document.getElementById('sessionDisplay');
const streamToggle = document.getElementById('streamToggle');
const newChatBtn = document.getElementById('newChatBtn');

// Initialize
sessionDisplay.textContent = sessionId;

// Toggle streaming

// New chat
newChatBtn.addEventListener('click', () => {
  sessionId = generateSessionId();
  sessionDisplay.textContent = sessionId;
  messagesContainer.innerHTML = `
    <div class="empty-state">
      <div class="empty-icon">üí∞</div>
      <div class="empty-title">Welcome to Your Financial Advisor</div>
      <div class="empty-subtitle">
        I'm here to help you navigate your financial journey. 
        Ask me about budgeting, investments, savings strategies, or any financial concerns you have.
      </div>
    </div>
  `;
});

// Parse markdown
function parseMarkdown(text) {
  return marked.parse(text, { breaks: true });
}

// Clear empty state
function clearEmptyState() {
  const emptyState = messagesContainer.querySelector('.empty-state');
  if (emptyState) {
    emptyState.remove();
  }
}

// Add message
function addMessage(content, role, isComplete = true) {
  clearEmptyState();
  
  const block = document.createElement('div');
  block.className = `message-block ${role}`;
  block.dataset.role = role;
  
  const avatar = document.createElement('div');
  avatar.className = 'msg-avatar-circle';
  avatar.textContent = role === 'user' ? 'üë§' : 'ü§ñ';
  
  const wrapper = document.createElement('div');
  wrapper.className = 'msg-wrapper';
  
  const label = document.createElement('div');
  label.className = 'msg-sender-label';
  label.textContent = role === 'user' ? 'Voc√™' : 'Chat Tributo';
  
  const contentBox = document.createElement('div');
  contentBox.className = 'msg-content-box';
  
  if (role === 'assistant' && !isComplete) {
    contentBox.innerHTML = content;
    const cursor = document.createElement('span');
    cursor.className = 'streaming-cursor';
    contentBox.appendChild(cursor);
  } else {
    contentBox.innerHTML = role === 'assistant' ? parseMarkdown(content) : content;
  }
  
  wrapper.appendChild(label);
  wrapper.appendChild(contentBox);
  block.appendChild(avatar);
  block.appendChild(wrapper);
  messagesContainer.appendChild(block);
  messagesContainer.scrollTop = messagesContainer.scrollHeight;
  
  return contentBox;
}

// Update streaming message
function updateStreamingMessage(contentBox, newContent, isComplete = false) {
  const cursor = contentBox.querySelector('.streaming-cursor');
  if (cursor) cursor.remove();

  if (!isComplete) {
    // DURING STREAMING ‚Üí show plain text, preserve paragraphs
    contentBox.textContent = newContent;
  } else {
    // AFTER STREAM FINISHES ‚Üí apply markdown safely
    contentBox.innerHTML = parseMarkdown(newContent);
  }

  if (!isComplete) {
    const newCursor = document.createElement('span');
    newCursor.className = 'streaming-cursor';
    contentBox.appendChild(newCursor);
  }

  messagesContainer.scrollTop = messagesContainer.scrollHeight;
}

// Send message with streaming
async function sendMessage() {
  const message = userInput.value.trim();
  if (!message || isStreaming) return;
  
  addMessage(message, 'user');
  userInput.value = '';
  sendButton.disabled = true;
  
  if (streamingEnabled) {
    isStreaming = true;
    let fullResponse = '';
    const contentBox = addMessage('', 'assistant', false);
    
    try {
      const response = await fetch(ENDPOINT, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          message: message,
          session_id: sessionId,
          stream: true,
          language: 'en'
        })
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let sseBuffer = '';
      let streamEnded = false;
      
      while (true) {
        const { value, done } = await reader.read();
        if (done) {
          // process any remaining buffer as final events
          if (sseBuffer.length > 0) {
            processSSEChunk(sseBuffer, true);
            sseBuffer = '';
          }
          break;
        }
        
        const chunk = decoder.decode(value, { stream: true });
        sseBuffer += chunk;
        
        // Process complete SSE events separated by blank line (supports \r\n\r\n too)
        const events = sseBuffer.split(/\r\n\r\n|\n\n/);
        // leave last (possibly incomplete) part in buffer
        sseBuffer = events.pop();
        
        for (const ev of events) {
          if (streamEnded) break;
          processSSEChunk(ev, false);
        }
        if (streamEnded) break;
      }
      
      // helper: process one raw SSE event chunk (may contain multiple data: lines)
      function processSSEChunk(raw, isFinal) {
        // split into lines, accept \r\n or \n
        const lines = raw.split(/\r?\n/);
        const dataLines = [];
        for (const line of lines) {
          // accept lines like "data: ..." or "data:..." (trim optional space)
          const m = line.match(/^data:\s?(.*)$/);
          if (m) {
            dataLines.push(m[1]);
          }
        }
        if (dataLines.length === 0) {
          return;
        }
        const data = dataLines.join('\n');
        if (data === '[DONE]') {
          // finalize
          updateStreamingMessage(contentBox, fullResponse, true);
          streamEnded = true;
          return;
        }
        // Append the data exactly as received (preserves paragraph separators sent by server)
        fullResponse += data;
        updateStreamingMessage(contentBox, fullResponse, false);
        
        if (isFinal) {
          updateStreamingMessage(contentBox, fullResponse, true);
        }
      }
      
    } catch (error) {
      updateStreamingMessage(contentBox, `Error: ${error.message}`, true);
    } finally {
      isStreaming = false;
      sendButton.disabled = false;
    }
  } else {
    // Non-streaming
    
    // Create loading animation bubble (same style as streaming)
    const loadingContentBox = addMessage('', 'assistant', false); // <-- this IS the content box
    const loadingCursor = loadingContentBox.querySelector('.streaming-cursor');
    loadingCursor.style.display = 'inline-block';
    
    try {
      const response = await fetch(ENDPOINT, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          message: message,
          session_id: sessionId,
          stream: false,
          language: 'en'
        })
      });
    
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
    
      const data = await response.json();
      const reply = data.reply || data.message || 'No response';
    
      // ‚úÖ Replace content of the SAME bubble
      loadingContentBox.innerHTML = parseMarkdown(reply);
    
    } catch (error) {
      loadingContentBox.innerHTML = `Error: ${error.message}`;
    } finally {
      sendButton.disabled = false;
    }
  }
}

// Event listeners
sendButton.addEventListener('click', sendMessage);
userInput.addEventListener('keypress', (e) => {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault();
    sendMessage();
  }
});
</script>
</body>
</html>
